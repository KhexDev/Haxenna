// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_ChartEditor
#include <ChartEditor.h>
#endif
#ifndef INCLUDED_Note
#include <Note.h>
#endif
#ifndef INCLUDED_Paths
#include <Paths.h>
#endif
#ifndef INCLUDED_PlayState
#include <PlayState.h>
#endif
#ifndef INCLUDED_Receptors
#include <Receptors.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroupIterator
#include <flixel/group/FlxTypedGroupIterator.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_util_FlxAxes
#include <flixel/util/FlxAxes.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSave
#include <flixel/util/FlxSave.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_7dddcbf2491d7af8_9_new,"ChartEditor","new",0xda0c677d,"ChartEditor.new","ChartEditor.hx",9,0x8f53d693)
HX_LOCAL_STACK_FRAME(_hx_pos_7dddcbf2491d7af8_33_create,"ChartEditor","create",0x67ba5fff,"ChartEditor.create","ChartEditor.hx",33,0x8f53d693)
static const ::String _hx_array_data_8691e50b_4[] = {
	HX_("LEFT",07,d0,70,32),HX_("DOWN",62,c0,2e,2d),HX_("UP",5b,4a,00,00),HX_("RIGHT",bc,43,52,67),
};
static const ::String _hx_array_data_8691e50b_5[] = {
	HX_("left",07,08,b0,47),HX_("down",62,f8,6d,42),HX_("up",5b,66,00,00),HX_("right",dc,0b,64,e9),
};
HX_LOCAL_STACK_FRAME(_hx_pos_7dddcbf2491d7af8_85_generateArrow,"ChartEditor","generateArrow",0xc639c7b1,"ChartEditor.generateArrow","ChartEditor.hx",85,0x8f53d693)
HX_LOCAL_STACK_FRAME(_hx_pos_7dddcbf2491d7af8_91_update,"ChartEditor","update",0x72b07f0c,"ChartEditor.update","ChartEditor.hx",91,0x8f53d693)

void ChartEditor_obj::__construct( ::Dynamic MaxSize){
            	HX_GC_STACKFRAME(&_hx_pos_7dddcbf2491d7af8_9_new)
HXLINE(  15)		this->savedNotes = ( (::cpp::VirtualArray)(::flixel::FlxG_obj::save->data->__Field(HX_("notes",41,dc,ca,9f),::hx::paccDynamic)) );
HXLINE(  13)		this->notWork =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,10,100,0,HX_("DOESNT WORK YET",3a,ca,a6,d1),50,null());
HXLINE(   9)		super::__construct(MaxSize);
            	}

Dynamic ChartEditor_obj::__CreateEmpty() { return new ChartEditor_obj; }

void *ChartEditor_obj::_hx_vtable = 0;

Dynamic ChartEditor_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ChartEditor_obj > _hx_result = new ChartEditor_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool ChartEditor_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x398d2a4b) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x398d2a4b;
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void ChartEditor_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_7dddcbf2491d7af8_33_create)
HXLINE(  34)		this->playing = false;
HXLINE(  36)		this->chartBG =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(500,2000,-1,null(),null());
HXLINE(  37)		this->chartBG->screenCenter(::flixel::util::FlxAxes_obj::X_dyn());
HXLINE(  38)		this->chartBG->set_y(( (Float)(0) ));
HXLINE(  39)		this->add(this->chartBG);
HXLINE(  41)		this->playerStrums =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  42)		this->add(this->playerStrums);
HXLINE(  43)		::ChartEditor_obj::receptors =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  44)		this->add(::ChartEditor_obj::receptors);
HXLINE(  45)		this->notes =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  46)		this->add(this->notes);
HXLINE(  48)		this->add(this->notWork);
HXLINE(  50)		::Array< ::String > dataPos = ::Array_obj< ::String >::fromData( _hx_array_data_8691e50b_4,4);
HXLINE(  51)		::Array< ::String > dataPos2 = ::Array_obj< ::String >::fromData( _hx_array_data_8691e50b_5,4);
HXLINE(  53)		{
HXLINE(  53)			int _g = 0;
HXDLIN(  53)			while((_g < 4)){
HXLINE(  53)				_g = (_g + 1);
HXDLIN(  53)				int i = (_g - 1);
HXLINE(  55)				this->strumLine =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  56)				this->staticArrow =  ::Receptors_obj::__alloc( HX_CTX );
HXLINE(  59)				 ::Receptors _hx_tmp = this->staticArrow;
HXDLIN(  59)				_hx_tmp->set_frames(::Paths_obj::getSparrowAtlas(HX_("Arrows",aa,8a,8f,ec)));
HXLINE(  60)				this->staticArrow->animation->addByPrefix(HX_("static",ae,dc,fb,05),(HX_("arrow",c9,79,8f,25) + dataPos->__get(i)),24,false,null(),null());
HXLINE(  61)				this->staticArrow->animation->addByPrefix(HX_("pressed",a2,d2,e6,39),(dataPos2->__get(i) + HX_(" press",63,df,f3,93)),24,false,null(),null());
HXLINE(  62)				this->staticArrow->animation->addByPrefix(HX_("confirm",00,9d,39,10),(dataPos2->__get(i) + HX_(" confirm",e0,e0,87,36)),24,false,null(),null());
HXLINE(  63)				this->staticArrow->animation->play(HX_("static",ae,dc,fb,05),null(),null(),null());
HXLINE(  65)				 ::Receptors _hx_tmp1 = this->staticArrow;
HXDLIN(  65)				_hx_tmp1->setGraphicSize(::Std_obj::_hx_int((this->staticArrow->get_width() * ((Float)0.5))),null());
HXLINE(  66)				this->staticArrow->set_y(( (Float)(50) ));
HXLINE(  67)				this->staticArrow->set_x(((( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) )) - ( (Float)(270) )));
HXLINE(  68)				{
HXLINE(  68)					 ::Receptors _g1 = this->staticArrow;
HXDLIN(  68)					Float _g2 = _g1->x;
HXDLIN(  68)					_g1->set_x((_g2 + ((this->staticArrow->get_width() - ( (Float)(30) )) * ( (Float)(i) ))));
            				}
HXLINE(  69)				 ::flixel::FlxSprite _hx_tmp2 = this->strumLine;
HXDLIN(  69)				Float _hx_tmp3 = this->staticArrow->x;
HXDLIN(  69)				_hx_tmp2->set_x((_hx_tmp3 + (this->staticArrow->get_width() / ( (Float)(2) ))));
HXLINE(  70)				this->strumLine->set_alpha(( (Float)(0) ));
HXLINE(  71)				::ChartEditor_obj::receptors->add(this->staticArrow).StaticCast<  ::Receptors >();
HXLINE(  72)				this->playerStrums->add(this->strumLine).StaticCast<  ::flixel::FlxSprite >();
            			}
            		}
HXLINE(  75)		::haxe::Log_obj::trace(this->savedNotes,::hx::SourceInfo(HX_("source/ChartEditor.hx",87,a8,ed,58),75,HX_("ChartEditor",0b,e5,91,86),HX_("create",fc,66,0f,7c)));
HXLINE(  77)		{
HXLINE(  77)			int _g1 = 0;
HXDLIN(  77)			int _g2 = this->savedNotes->get_length();
HXDLIN(  77)			while((_g1 < _g2)){
HXLINE(  77)				_g1 = (_g1 + 1);
HXDLIN(  77)				int i = (_g1 - 1);
HXLINE(  79)				this->generateArrow(( (int)(this->savedNotes->__get(i)->__GetItem(1)) ),( (Float)(this->savedNotes->__get(i)->__GetItem(0)) ));
            			}
            		}
HXLINE(  81)		this->super::create();
            	}


void ChartEditor_obj::generateArrow(int noteData,Float songPosition){
            	HX_GC_STACKFRAME(&_hx_pos_7dddcbf2491d7af8_85_generateArrow)
HXLINE(  86)		this->daNote =  ::Note_obj::__alloc( HX_CTX ,(Dynamic( this->playerStrums->members->__get(noteData)).StaticCast<  ::flixel::FlxSprite >()->x - ( (Float)(80) )),(songPosition - ( (Float)(500) )),noteData,HX_("normal",27,72,69,30),true);
HXLINE(  87)		this->notes->add(this->daNote).StaticCast<  ::Note >();
            	}


HX_DEFINE_DYNAMIC_FUNC2(ChartEditor_obj,generateArrow,(void))

void ChartEditor_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_7dddcbf2491d7af8_91_update)
HXLINE(  92)		this->ghostNote =  ::Note_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),0,HX_("normal",27,72,69,30),false);
HXLINE(  93)		 ::Note _hx_tmp = this->ghostNote;
HXDLIN(  93)		int _hx_tmp1 = ::flixel::FlxG_obj::mouse->x;
HXDLIN(  93)		_hx_tmp->set_x((( (Float)(_hx_tmp1) ) - (this->ghostNote->get_width() / ( (Float)(2) ))));
HXLINE(  94)		 ::Note _hx_tmp2 = this->ghostNote;
HXDLIN(  94)		int _hx_tmp3 = ::flixel::FlxG_obj::mouse->y;
HXDLIN(  94)		_hx_tmp2->set_y((( (Float)(_hx_tmp3) ) - (this->ghostNote->get_height() / ( (Float)(2) ))));
HXLINE(  95)		this->ghostNote->set_alpha(((Float)0.3));
HXLINE(  97)		if (!(this->ghostNote->exists)) {
HXLINE(  98)			this->add(this->ghostNote);
            		}
HXLINE( 100)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 100)		if (_this->keyManager->checkStatus(32,_this->status)) {
HXLINE( 101)			this->playing = !(this->playing);
            		}
HXLINE( 103)		{
HXLINE( 103)			 ::Dynamic filter = null();
HXDLIN( 103)			 ::flixel::group::FlxTypedGroupIterator note =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->notes->members,filter);
HXDLIN( 103)			while(note->hasNext()){
HXLINE( 103)				 ::Note note1 = note->next().StaticCast<  ::Note >();
HXLINE( 105)				if (this->playing) {
HXLINE( 106)					 ::Note _g = note1;
HXDLIN( 106)					_g->set_y((_g->y - ( (Float)(20) )));
            				}
            				else {
HXLINE( 108)					 ::Note _g = note1;
HXDLIN( 108)					_g->set_y((_g->y + (::flixel::FlxG_obj::mouse->wheel * 144)));
            				}
            			}
            		}
HXLINE( 111)		 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 111)		if (_this1->keyManager->checkStatus(8,_this1->status)) {
HXLINE( 112)			 ::flixel::FlxState nextState =  ::PlayState_obj::__alloc( HX_CTX ,null());
HXDLIN( 112)			if (::flixel::FlxG_obj::game->_state->switchTo(nextState)) {
HXLINE( 112)				::flixel::FlxG_obj::game->_requestedState = nextState;
            			}
            		}
HXLINE( 114)		this->super::update(elapsed);
            	}


 ::flixel::group::FlxTypedGroup ChartEditor_obj::receptors;


::hx::ObjectPtr< ChartEditor_obj > ChartEditor_obj::__new( ::Dynamic MaxSize) {
	::hx::ObjectPtr< ChartEditor_obj > __this = new ChartEditor_obj();
	__this->__construct(MaxSize);
	return __this;
}

::hx::ObjectPtr< ChartEditor_obj > ChartEditor_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic MaxSize) {
	ChartEditor_obj *__this = (ChartEditor_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ChartEditor_obj), true, "ChartEditor"));
	*(void **)__this = ChartEditor_obj::_hx_vtable;
	__this->__construct(MaxSize);
	return __this;
}

ChartEditor_obj::ChartEditor_obj()
{
}

void ChartEditor_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ChartEditor);
	HX_MARK_MEMBER_NAME(playing,"playing");
	HX_MARK_MEMBER_NAME(notWork,"notWork");
	HX_MARK_MEMBER_NAME(savedNotes,"savedNotes");
	HX_MARK_MEMBER_NAME(chartBG,"chartBG");
	HX_MARK_MEMBER_NAME(fromPlayState,"fromPlayState");
	HX_MARK_MEMBER_NAME(staticArrow,"staticArrow");
	HX_MARK_MEMBER_NAME(daNote,"daNote");
	HX_MARK_MEMBER_NAME(ghostNote,"ghostNote");
	HX_MARK_MEMBER_NAME(notes,"notes");
	HX_MARK_MEMBER_NAME(strumLine,"strumLine");
	HX_MARK_MEMBER_NAME(playerStrums,"playerStrums");
	 ::flixel::FlxState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ChartEditor_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(playing,"playing");
	HX_VISIT_MEMBER_NAME(notWork,"notWork");
	HX_VISIT_MEMBER_NAME(savedNotes,"savedNotes");
	HX_VISIT_MEMBER_NAME(chartBG,"chartBG");
	HX_VISIT_MEMBER_NAME(fromPlayState,"fromPlayState");
	HX_VISIT_MEMBER_NAME(staticArrow,"staticArrow");
	HX_VISIT_MEMBER_NAME(daNote,"daNote");
	HX_VISIT_MEMBER_NAME(ghostNote,"ghostNote");
	HX_VISIT_MEMBER_NAME(notes,"notes");
	HX_VISIT_MEMBER_NAME(strumLine,"strumLine");
	HX_VISIT_MEMBER_NAME(playerStrums,"playerStrums");
	 ::flixel::FlxState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val ChartEditor_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"notes") ) { return ::hx::Val( notes ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"daNote") ) { return ::hx::Val( daNote ); }
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"playing") ) { return ::hx::Val( playing ); }
		if (HX_FIELD_EQ(inName,"notWork") ) { return ::hx::Val( notWork ); }
		if (HX_FIELD_EQ(inName,"chartBG") ) { return ::hx::Val( chartBG ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"ghostNote") ) { return ::hx::Val( ghostNote ); }
		if (HX_FIELD_EQ(inName,"strumLine") ) { return ::hx::Val( strumLine ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"savedNotes") ) { return ::hx::Val( savedNotes ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"staticArrow") ) { return ::hx::Val( staticArrow ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"playerStrums") ) { return ::hx::Val( playerStrums ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"fromPlayState") ) { return ::hx::Val( fromPlayState ); }
		if (HX_FIELD_EQ(inName,"generateArrow") ) { return ::hx::Val( generateArrow_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool ChartEditor_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"receptors") ) { outValue = ( receptors ); return true; }
	}
	return false;
}

::hx::Val ChartEditor_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"notes") ) { notes=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"daNote") ) { daNote=inValue.Cast<  ::Note >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"playing") ) { playing=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"notWork") ) { notWork=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"chartBG") ) { chartBG=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"ghostNote") ) { ghostNote=inValue.Cast<  ::Note >(); return inValue; }
		if (HX_FIELD_EQ(inName,"strumLine") ) { strumLine=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"savedNotes") ) { savedNotes=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"staticArrow") ) { staticArrow=inValue.Cast<  ::Receptors >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"playerStrums") ) { playerStrums=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"fromPlayState") ) { fromPlayState=inValue.Cast<  ::PlayState >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool ChartEditor_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"receptors") ) { receptors=ioValue.Cast<  ::flixel::group::FlxTypedGroup >(); return true; }
	}
	return false;
}

void ChartEditor_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("playing",6e,0f,18,8a));
	outFields->push(HX_("notWork",84,8c,27,44));
	outFields->push(HX_("savedNotes",3a,78,cd,42));
	outFields->push(HX_("chartBG",23,4a,7b,cf));
	outFields->push(HX_("fromPlayState",b3,e0,d8,18));
	outFields->push(HX_("staticArrow",3b,56,5c,3a));
	outFields->push(HX_("daNote",0f,9e,71,09));
	outFields->push(HX_("ghostNote",e1,26,d7,1c));
	outFields->push(HX_("notes",41,dc,ca,9f));
	outFields->push(HX_("strumLine",dd,79,d7,ee));
	outFields->push(HX_("playerStrums",4b,e1,2a,0d));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ChartEditor_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(ChartEditor_obj,playing),HX_("playing",6e,0f,18,8a)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(ChartEditor_obj,notWork),HX_("notWork",84,8c,27,44)},
	{::hx::fsObject /* ::cpp::VirtualArray */ ,(int)offsetof(ChartEditor_obj,savedNotes),HX_("savedNotes",3a,78,cd,42)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(ChartEditor_obj,chartBG),HX_("chartBG",23,4a,7b,cf)},
	{::hx::fsObject /*  ::PlayState */ ,(int)offsetof(ChartEditor_obj,fromPlayState),HX_("fromPlayState",b3,e0,d8,18)},
	{::hx::fsObject /*  ::Receptors */ ,(int)offsetof(ChartEditor_obj,staticArrow),HX_("staticArrow",3b,56,5c,3a)},
	{::hx::fsObject /*  ::Note */ ,(int)offsetof(ChartEditor_obj,daNote),HX_("daNote",0f,9e,71,09)},
	{::hx::fsObject /*  ::Note */ ,(int)offsetof(ChartEditor_obj,ghostNote),HX_("ghostNote",e1,26,d7,1c)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(ChartEditor_obj,notes),HX_("notes",41,dc,ca,9f)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(ChartEditor_obj,strumLine),HX_("strumLine",dd,79,d7,ee)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(ChartEditor_obj,playerStrums),HX_("playerStrums",4b,e1,2a,0d)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo ChartEditor_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(void *) &ChartEditor_obj::receptors,HX_("receptors",37,7d,22,c1)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String ChartEditor_obj_sMemberFields[] = {
	HX_("playing",6e,0f,18,8a),
	HX_("notWork",84,8c,27,44),
	HX_("savedNotes",3a,78,cd,42),
	HX_("chartBG",23,4a,7b,cf),
	HX_("fromPlayState",b3,e0,d8,18),
	HX_("staticArrow",3b,56,5c,3a),
	HX_("daNote",0f,9e,71,09),
	HX_("ghostNote",e1,26,d7,1c),
	HX_("notes",41,dc,ca,9f),
	HX_("strumLine",dd,79,d7,ee),
	HX_("playerStrums",4b,e1,2a,0d),
	HX_("create",fc,66,0f,7c),
	HX_("generateArrow",54,4a,0c,cc),
	HX_("update",09,86,05,87),
	::String(null()) };

static void ChartEditor_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ChartEditor_obj::receptors,"receptors");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ChartEditor_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ChartEditor_obj::receptors,"receptors");
};

#endif

::hx::Class ChartEditor_obj::__mClass;

static ::String ChartEditor_obj_sStaticFields[] = {
	HX_("receptors",37,7d,22,c1),
	::String(null())
};

void ChartEditor_obj::__register()
{
	ChartEditor_obj _hx_dummy;
	ChartEditor_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("ChartEditor",0b,e5,91,86);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ChartEditor_obj::__GetStatic;
	__mClass->mSetStaticField = &ChartEditor_obj::__SetStatic;
	__mClass->mMarkFunc = ChartEditor_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ChartEditor_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ChartEditor_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ChartEditor_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ChartEditor_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ChartEditor_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ChartEditor_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

