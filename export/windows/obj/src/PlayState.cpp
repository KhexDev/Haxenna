// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_ChartEditor
#include <ChartEditor.h>
#endif
#ifndef INCLUDED_Conductor
#include <Conductor.h>
#endif
#ifndef INCLUDED_Judge
#include <Judge.h>
#endif
#ifndef INCLUDED_Note
#include <Note.h>
#endif
#ifndef INCLUDED_Paths
#include <Paths.h>
#endif
#ifndef INCLUDED_PlayState
#include <PlayState.h>
#endif
#ifndef INCLUDED_Receptors
#include <Receptors.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroupIterator
#include <flixel/group/FlxTypedGroupIterator.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxBar
#include <flixel/ui/FlxBar.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxBarFillDirection
#include <flixel/ui/FlxBarFillDirection.h>
#endif
#ifndef INCLUDED_flixel_util_FlxAxes
#include <flixel/util/FlxAxes.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSave
#include <flixel/util/FlxSave.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_openfl_Lib
#include <openfl/Lib.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_MovieClip
#include <openfl/display/MovieClip.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_display_Stage
#include <openfl/display/Stage.h>
#endif
#ifndef INCLUDED_openfl_events_Event
#include <openfl/events/Event.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_KeyboardEvent
#include <openfl/events/KeyboardEvent.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_af23706db05c7feb_24_new,"PlayState","new",0xf8bf96cf,"PlayState.new","PlayState.hx",24,0xb30d7781)
static const bool _hx_array_data_46c2835d_1[] = {
	0,0,0,0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_af23706db05c7feb_54_create,"PlayState","create",0x82220fed,"PlayState.create","PlayState.hx",54,0xb30d7781)
static const ::String _hx_array_data_46c2835d_4[] = {
	HX_("LEFT",07,d0,70,32),HX_("DOWN",62,c0,2e,2d),HX_("UP",5b,4a,00,00),HX_("RIGHT",bc,43,52,67),
};
static const ::String _hx_array_data_46c2835d_5[] = {
	HX_("left",07,08,b0,47),HX_("down",62,f8,6d,42),HX_("up",5b,66,00,00),HX_("right",dc,0b,64,e9),
};
HX_LOCAL_STACK_FRAME(_hx_pos_af23706db05c7feb_110_generateArrow,"PlayState","generateArrow",0x7f9c1183,"PlayState.generateArrow","PlayState.hx",110,0xb30d7781)
HX_LOCAL_STACK_FRAME(_hx_pos_af23706db05c7feb_117_generateSong,"PlayState","generateSong",0x3a61615b,"PlayState.generateSong","PlayState.hx",117,0xb30d7781)
HX_LOCAL_STACK_FRAME(_hx_pos_af23706db05c7feb_218_handInput,"PlayState","handInput",0xc5b6f9ca,"PlayState.handInput","PlayState.hx",218,0xb30d7781)
HX_LOCAL_STACK_FRAME(_hx_pos_af23706db05c7feb_241_realeasedInput,"PlayState","realeasedInput",0x19336a43,"PlayState.realeasedInput","PlayState.hx",241,0xb30d7781)
HX_LOCAL_STACK_FRAME(_hx_pos_af23706db05c7feb_255_addAccuracyText,"PlayState","addAccuracyText",0x4a2cac36,"PlayState.addAccuracyText","PlayState.hx",255,0xb30d7781)
HX_LOCAL_STACK_FRAME(_hx_pos_af23706db05c7feb_264_update,"PlayState","update",0x8d182efa,"PlayState.update","PlayState.hx",264,0xb30d7781)

void PlayState_obj::__construct( ::Dynamic MaxSize){
            	HX_STACKFRAME(&_hx_pos_af23706db05c7feb_24_new)
HXLINE( 201)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 201)		bool _hx_tmp = _this->keyManager->checkStatus(81,_this->status);
HXLINE( 202)		 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 202)		bool _hx_tmp1 = _this1->keyManager->checkStatus(83,_this1->status);
HXLINE( 203)		 ::flixel::input::keyboard::FlxKeyList _this2 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 203)		bool _hx_tmp2 = _this2->keyManager->checkStatus(76,_this2->status);
HXLINE( 204)		 ::flixel::input::keyboard::FlxKeyList _this3 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXLINE( 200)		this->keys = ::Array_obj< bool >::__new(4)->init(0,_hx_tmp)->init(1,_hx_tmp1)->init(2,_hx_tmp2)->init(3,_this3->keyManager->checkStatus(77,_this3->status));
HXLINE(  39)		this->holdTimer = ((Float)0.0);
HXLINE(  38)		this->noteBool = ::Array_obj< bool >::fromData( _hx_array_data_46c2835d_1,4);
HXLINE(  34)		this->health = 100;
HXLINE(  24)		super::__construct(MaxSize);
            	}

Dynamic PlayState_obj::__CreateEmpty() { return new PlayState_obj; }

void *PlayState_obj::_hx_vtable = 0;

Dynamic PlayState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PlayState_obj > _hx_result = new PlayState_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool PlayState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x0a05f89d) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0a05f89d;
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void PlayState_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_af23706db05c7feb_54_create)
HXLINE(  57)		this->shitSprite =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(400,600,-1,null(),null());
HXLINE(  58)		this->add(this->shitSprite);
HXLINE(  60)		this->playerStrums =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  61)		this->add(this->playerStrums);
HXLINE(  62)		::PlayState_obj::receptors =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  63)		this->add(::PlayState_obj::receptors);
HXLINE(  64)		this->notes =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  65)		this->add(this->notes);
HXLINE(  66)		this->lifeBar =  ::flixel::ui::FlxBar_obj::__alloc( HX_CTX ,0,0,::flixel::ui::FlxBarFillDirection_obj::LEFT_TO_RIGHT_dyn(),::Std_obj::_hx_int((( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))),20,null(),null(),0,100,null());
HXLINE(  67)		this->lifeBar->set_numDivisions(150);
HXLINE(  68)		this->lifeBar->set_percent(( (Float)(this->health) ));
HXLINE(  69)		this->lifeBar->createColoredEmptyBar(-65536,null(),null());
HXLINE(  70)		this->lifeBar->createColoredFilledBar(-16776961,null(),null());
HXLINE(  71)		this->lifeBar->screenCenter(::flixel::util::FlxAxes_obj::XY_dyn());
HXLINE(  72)		{
HXLINE(  72)			 ::flixel::ui::FlxBar _g = this->lifeBar;
HXDLIN(  72)			_g->set_y((_g->y + 300));
            		}
HXLINE(  73)		this->add(this->lifeBar);
HXLINE(  75)		::Array< ::String > dataPos = ::Array_obj< ::String >::fromData( _hx_array_data_46c2835d_4,4);
HXLINE(  76)		::Array< ::String > dataPos2 = ::Array_obj< ::String >::fromData( _hx_array_data_46c2835d_5,4);
HXLINE(  78)		{
HXLINE(  78)			int _g1 = 0;
HXDLIN(  78)			while((_g1 < 4)){
HXLINE(  78)				_g1 = (_g1 + 1);
HXDLIN(  78)				int i = (_g1 - 1);
HXLINE(  80)				this->strumLine =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  81)				this->staticArrow =  ::Receptors_obj::__alloc( HX_CTX );
HXLINE(  84)				 ::Receptors _hx_tmp = this->staticArrow;
HXDLIN(  84)				_hx_tmp->set_frames(::Paths_obj::getSparrowAtlas(HX_("Arrows",aa,8a,8f,ec)));
HXLINE(  85)				this->staticArrow->animation->addByPrefix(HX_("static",ae,dc,fb,05),(HX_("arrow",c9,79,8f,25) + dataPos->__get(i)),24,false,null(),null());
HXLINE(  86)				this->staticArrow->animation->addByPrefix(HX_("pressed",a2,d2,e6,39),(dataPos2->__get(i) + HX_(" press",63,df,f3,93)),24,false,null(),null());
HXLINE(  87)				this->staticArrow->animation->addByPrefix(HX_("confirm",00,9d,39,10),(dataPos2->__get(i) + HX_(" confirm",e0,e0,87,36)),24,false,null(),null());
HXLINE(  88)				this->staticArrow->animation->play(HX_("static",ae,dc,fb,05),null(),null(),null());
HXLINE(  90)				 ::Receptors _hx_tmp1 = this->staticArrow;
HXDLIN(  90)				_hx_tmp1->setGraphicSize(::Std_obj::_hx_int((this->staticArrow->get_width() * ((Float)0.7))),null());
HXLINE(  91)				this->staticArrow->set_y(( (Float)(50) ));
HXLINE(  92)				this->staticArrow->set_x(((( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) )) - ( (Float)(270) )));
HXLINE(  93)				{
HXLINE(  93)					 ::Receptors _g = this->staticArrow;
HXDLIN(  93)					Float _g2 = _g->x;
HXDLIN(  93)					_g->set_x((_g2 + ((this->staticArrow->get_width() - ( (Float)(20) )) * ( (Float)(i) ))));
            				}
HXLINE(  94)				 ::flixel::FlxSprite _hx_tmp2 = this->strumLine;
HXDLIN(  94)				Float _hx_tmp3 = this->staticArrow->x;
HXDLIN(  94)				_hx_tmp2->set_x((_hx_tmp3 + (this->staticArrow->get_width() / ( (Float)(2) ))));
HXLINE(  95)				this->strumLine->set_alpha(( (Float)(0) ));
HXLINE(  96)				::PlayState_obj::receptors->add(this->staticArrow).StaticCast<  ::Receptors >();
HXLINE(  97)				this->playerStrums->add(this->strumLine).StaticCast<  ::flixel::FlxSprite >();
            			}
            		}
HXLINE( 100)		::openfl::Lib_obj::get_current()->stage->addEventListener(HX_("keyDown",a1,69,47,9c),this->handInput_dyn(),null(),null(),null());
HXLINE( 101)		::openfl::Lib_obj::get_current()->stage->addEventListener(HX_("keyUp",da,b9,fe,de),this->realeasedInput_dyn(),null(),null(),null());
HXLINE( 103)		this->generateSong();
HXLINE( 106)		this->super::create();
            	}


void PlayState_obj::generateArrow(int noteData,Float songPosition){
            	HX_GC_STACKFRAME(&_hx_pos_af23706db05c7feb_110_generateArrow)
HXLINE( 111)		this->daNote =  ::Note_obj::__alloc( HX_CTX ,(Dynamic( this->playerStrums->members->__get(noteData)).StaticCast<  ::flixel::FlxSprite >()->x - ( (Float)(80) )),songPosition,noteData,HX_("normal",27,72,69,30),false);
HXLINE( 112)		this->notes->add(this->daNote).StaticCast<  ::Note >();
            	}


HX_DEFINE_DYNAMIC_FUNC2(PlayState_obj,generateArrow,(void))

void PlayState_obj::generateSong(){
            	HX_GC_STACKFRAME(&_hx_pos_af23706db05c7feb_117_generateSong)
HXLINE( 118)		::String jsonChart = ::sys::io::File_obj::getContent(HX_("assets/data/dadbattle-hard.json",e4,de,3b,d6));
HXLINE( 119)		 ::Dynamic chart =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,jsonChart)->doParse();
HXLINE( 121)		::haxe::Log_obj::trace( ::Dynamic(chart->__Field(HX_("song",d5,23,58,4c),::hx::paccDynamic)),::hx::SourceInfo(HX_("source/PlayState.hx",75,24,2b,b8),121,HX_("PlayState",5d,83,c2,46),HX_("generateSong",aa,ed,2b,1f)));
HXLINE( 123)		::Array< ::Dynamic> savedNotes = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 125)		::Conductor_obj::songPosition = ( (Float)(0) );
HXLINE( 132)		this->generateArrow(0,( (Float)(1000) ));
HXLINE( 133)		this->generateArrow(1,( (Float)(1000) ));
HXLINE( 134)		this->generateArrow(3,( (Float)(1000) ));
HXLINE( 135)		this->generateArrow(2,( (Float)(1200) ));
HXLINE( 136)		this->generateArrow(3,( (Float)(1400) ));
HXLINE( 137)		this->generateArrow(3,( (Float)(1600) ));
HXLINE( 138)		this->generateArrow(0,( (Float)(1800) ));
HXLINE( 139)		this->generateArrow(2,( (Float)(2000) ));
HXLINE( 140)		this->generateArrow(3,( (Float)(2000) ));
HXLINE( 141)		this->generateArrow(1,( (Float)(2200) ));
HXLINE( 142)		this->generateArrow(2,( (Float)(2400) ));
HXLINE( 143)		this->generateArrow(3,( (Float)(2600) ));
HXLINE( 144)		this->generateArrow(0,( (Float)(2800) ));
HXLINE( 146)		this->generateArrow(0,( (Float)(3000) ));
HXLINE( 147)		this->generateArrow(1,( (Float)(3200) ));
HXLINE( 148)		this->generateArrow(3,( (Float)(3400) ));
HXLINE( 149)		this->generateArrow(2,( (Float)(3600) ));
HXLINE( 150)		this->generateArrow(3,( (Float)(3800) ));
HXLINE( 152)		this->generateArrow(3,( (Float)(4000) ));
HXLINE( 153)		this->generateArrow(0,( (Float)(4000) ));
HXLINE( 154)		this->generateArrow(2,( (Float)(4000) ));
HXLINE( 155)		this->generateArrow(3,( (Float)(4200) ));
HXLINE( 156)		this->generateArrow(1,( (Float)(4200) ));
HXLINE( 157)		this->generateArrow(2,( (Float)(4400) ));
HXLINE( 158)		this->generateArrow(3,( (Float)(4400) ));
HXLINE( 159)		this->generateArrow(0,( (Float)(4400) ));
HXLINE( 161)		this->generateArrow(0,( (Float)(4600) ));
HXLINE( 162)		this->generateArrow(1,( (Float)(4600) ));
HXLINE( 163)		this->generateArrow(3,( (Float)(4600) ));
HXLINE( 164)		this->generateArrow(2,( (Float)(4800) ));
HXLINE( 165)		this->generateArrow(3,( (Float)(5000) ));
HXLINE( 166)		this->generateArrow(3,( (Float)(5200) ));
HXLINE( 167)		this->generateArrow(0,( (Float)(5200) ));
HXLINE( 168)		this->generateArrow(2,( (Float)(5400) ));
HXLINE( 169)		this->generateArrow(3,( (Float)(5600) ));
HXLINE( 170)		this->generateArrow(1,( (Float)(5600) ));
HXLINE( 171)		this->generateArrow(2,( (Float)(5800) ));
HXLINE( 172)		this->generateArrow(3,( (Float)(6000) ));
HXLINE( 173)		this->generateArrow(0,( (Float)(6000) ));
HXLINE( 175)		this->generateArrow(0,( (Float)(6200) ));
HXLINE( 176)		this->generateArrow(1,( (Float)(6400) ));
HXLINE( 177)		this->generateArrow(3,( (Float)(6600) ));
HXLINE( 178)		this->generateArrow(2,( (Float)(6600) ));
HXLINE( 179)		this->generateArrow(3,( (Float)(6800) ));
HXLINE( 181)		this->generateArrow(3,( (Float)(7000) ));
HXLINE( 182)		this->generateArrow(0,( (Float)(7200) ));
HXLINE( 183)		this->generateArrow(2,( (Float)(7400) ));
HXLINE( 184)		this->generateArrow(3,( (Float)(7600) ));
HXLINE( 185)		this->generateArrow(1,( (Float)(7800) ));
HXLINE( 186)		this->generateArrow(2,( (Float)(7800) ));
HXLINE( 187)		this->generateArrow(3,( (Float)(8000) ));
HXLINE( 188)		this->generateArrow(0,( (Float)(8000) ));
HXLINE( 191)		{
HXLINE( 191)			int _g = 0;
HXDLIN( 191)			int _g1 = this->notes->length;
HXDLIN( 191)			while((_g < _g1)){
HXLINE( 191)				_g = (_g + 1);
HXDLIN( 191)				int i = (_g - 1);
HXLINE( 193)				savedNotes->push(::Array_obj< Float >::__new(2)->init(0,Dynamic( this->notes->members->__get(i)).StaticCast<  ::Note >()->y)->init(1,Dynamic( this->notes->members->__get(i)).StaticCast<  ::Note >()->noteData));
            			}
            		}
HXLINE( 196)		::flixel::FlxG_obj::save->data->__SetField(HX_("notes",41,dc,ca,9f),savedNotes,::hx::paccDynamic);
            	}


HX_DEFINE_DYNAMIC_FUNC0(PlayState_obj,generateSong,(void))

void PlayState_obj::handInput( ::openfl::events::KeyboardEvent event){
            	HX_STACKFRAME(&_hx_pos_af23706db05c7feb_218_handInput)
HXDLIN( 218)		switch((int)(event->keyCode)){
            			case (int)76: {
HXLINE( 223)				this->noteBool[2] = true;
            			}
            			break;
            			case (int)77: {
HXLINE( 225)				this->noteBool[3] = true;
            			}
            			break;
            			case (int)81: {
HXLINE( 221)				this->noteBool[0] = true;
            			}
            			break;
            			case (int)83: {
HXLINE( 227)				this->noteBool[1] = true;
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(PlayState_obj,handInput,(void))

void PlayState_obj::realeasedInput( ::openfl::events::KeyboardEvent event){
            	HX_STACKFRAME(&_hx_pos_af23706db05c7feb_241_realeasedInput)
HXDLIN( 241)		switch((int)(event->keyCode)){
            			case (int)76: {
HXLINE( 246)				this->noteBool[2] = false;
            			}
            			break;
            			case (int)77: {
HXLINE( 248)				this->noteBool[3] = false;
            			}
            			break;
            			case (int)81: {
HXLINE( 244)				this->noteBool[0] = false;
            			}
            			break;
            			case (int)83: {
HXLINE( 250)				this->noteBool[1] = false;
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(PlayState_obj,realeasedInput,(void))

void PlayState_obj::addAccuracyText(::String text){
            	HX_GC_STACKFRAME(&_hx_pos_af23706db05c7feb_255_addAccuracyText)
HXLINE( 256)		this->remove(this->accuracyText,null());
HXLINE( 257)		this->accuracyText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,null(),null(),null(),text,50,null());
HXLINE( 258)		this->accuracyText->screenCenter(::flixel::util::FlxAxes_obj::XY_dyn());
HXLINE( 259)		this->add(this->accuracyText);
            	}


HX_DEFINE_DYNAMIC_FUNC1(PlayState_obj,addAccuracyText,(void))

void PlayState_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_af23706db05c7feb_264_update)
HXLINE( 265)		 ::Dynamic _hx_tmp = ::hx::ClassOf< ::Conductor >();
HXDLIN( 265)		::Conductor_obj::songPosition = (::Conductor_obj::songPosition + elapsed);
HXLINE( 267)		{
HXLINE( 267)			 ::Dynamic filter = null();
HXDLIN( 267)			 ::flixel::group::FlxTypedGroupIterator note =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->notes->members,filter);
HXDLIN( 267)			while(note->hasNext()){
HXLINE( 267)				 ::Note note1 = note->next().StaticCast<  ::Note >();
HXLINE( 269)				 ::Note _g = note1;
HXDLIN( 269)				_g->set_y((_g->y - ( (Float)(20) )));
            			}
            		}
HXLINE( 272)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 272)		if (_this->keyManager->checkStatus(55,_this->status)) {
HXLINE( 273)			 ::flixel::FlxState nextState =  ::ChartEditor_obj::__alloc( HX_CTX ,null());
HXDLIN( 273)			if (::flixel::FlxG_obj::game->_state->switchTo(nextState)) {
HXLINE( 273)				::flixel::FlxG_obj::game->_requestedState = nextState;
            			}
            		}
HXLINE( 275)		 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 275)		if (_this1->keyManager->checkStatus(32,_this1->status)) {
HXLINE( 276)			this->generateSong();
            		}
HXLINE( 278)		{
HXLINE( 278)			int _g = 0;
HXDLIN( 278)			int _g1 = this->noteBool->length;
HXDLIN( 278)			while((_g < _g1)){
HXLINE( 278)				_g = (_g + 1);
HXDLIN( 278)				int i = (_g - 1);
HXLINE( 280)				if (this->noteBool->__get(i)) {
HXLINE( 282)					Dynamic( ::PlayState_obj::receptors->members->__get(i)).StaticCast<  ::Receptors >()->animation->play(HX_("pressed",a2,d2,e6,39),null(),null(),null());
            				}
            				else {
HXLINE( 286)					Dynamic( ::PlayState_obj::receptors->members->__get(i)).StaticCast<  ::Receptors >()->animation->play(HX_("static",ae,dc,fb,05),null(),null(),null());
            				}
            			}
            		}
HXLINE( 291)		{
HXLINE( 291)			 ::Dynamic filter1 = null();
HXDLIN( 291)			 ::flixel::group::FlxTypedGroupIterator note1 =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->notes->members,filter1);
HXDLIN( 291)			while(note1->hasNext()){
HXLINE( 291)				 ::Note note = note1->next().StaticCast<  ::Note >();
HXLINE( 293)				if ((note->y <= (Dynamic( ::PlayState_obj::receptors->members->__get(note->noteData)).StaticCast<  ::Receptors >()->y + ::Judge_obj::judge->__get(0)))) {
HXLINE( 294)					::PlayState_obj::rating = HX_("sick",be,8c,53,4c);
            				}
            				else {
HXLINE( 295)					if ((note->y <= (Dynamic( ::PlayState_obj::receptors->members->__get(note->noteData)).StaticCast<  ::Receptors >()->y + ::Judge_obj::judge->__get(1)))) {
HXLINE( 296)						::PlayState_obj::rating = HX_("good",3d,95,69,44);
            					}
            					else {
HXLINE( 297)						if ((note->y <= (Dynamic( ::PlayState_obj::receptors->members->__get(note->noteData)).StaticCast<  ::Receptors >()->y + ::Judge_obj::judge->__get(2)))) {
HXLINE( 298)							::PlayState_obj::rating = HX_("bad",c5,b1,4a,00);
            						}
            					}
            				}
HXLINE( 300)				::Array< ::Dynamic> closestNote = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 302)				if (note->canBeHit) {
HXLINE( 303)					closestNote->push(note);
            				}
HXLINE( 305)				if ((note->y < -100)) {
HXLINE( 306)					note->kill();
            				}
HXLINE( 308)				{
HXLINE( 308)					int _g = 0;
HXDLIN( 308)					while((_g < closestNote->length)){
HXLINE( 308)						 ::Note i = closestNote->__get(_g).StaticCast<  ::Note >();
HXDLIN( 308)						_g = (_g + 1);
HXLINE( 310)						if ((i->y < (Dynamic( ::PlayState_obj::receptors->members->__get(i->noteData)).StaticCast<  ::Receptors >()->y - ( (Float)(100) )))) {
HXLINE( 312)							closestNote->remove(i);
            						}
HXLINE( 317)						bool _hx_tmp;
HXDLIN( 317)						if (this->noteBool->__get(i->noteData)) {
HXLINE( 317)							_hx_tmp = (i->y < (Dynamic( ::PlayState_obj::receptors->members->__get(i->noteData)).StaticCast<  ::Receptors >()->y + 100));
            						}
            						else {
HXLINE( 317)							_hx_tmp = false;
            						}
HXDLIN( 317)						if (_hx_tmp) {
HXLINE( 319)							i->kill();
HXLINE( 320)							closestNote->remove(i);
HXLINE( 322)							if (!(i->exists)) {
HXLINE( 323)								i->wasHit = true;
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 328)		if (this->noteBool->contains(true)) {
HXLINE( 330)			::haxe::Log_obj::trace(::PlayState_obj::sick,::hx::SourceInfo(HX_("source/PlayState.hx",75,24,2b,b8),330,HX_("PlayState",5d,83,c2,46),HX_("update",09,86,05,87)));
HXLINE( 331)			::haxe::Log_obj::trace(this->good,::hx::SourceInfo(HX_("source/PlayState.hx",75,24,2b,b8),331,HX_("PlayState",5d,83,c2,46),HX_("update",09,86,05,87)));
HXLINE( 332)			::haxe::Log_obj::trace(this->bads,::hx::SourceInfo(HX_("source/PlayState.hx",75,24,2b,b8),332,HX_("PlayState",5d,83,c2,46),HX_("update",09,86,05,87)));
HXLINE( 334)			::String _hx_switch_0 = ::PlayState_obj::rating;
            			if (  (_hx_switch_0==HX_("bad",c5,b1,4a,00)) ){
HXLINE( 343)				this->addAccuracyText(HX_("BAD",a5,4d,32,00));
HXLINE( 344)				this->bads++;
HXLINE( 342)				goto _hx_goto_16;
            			}
            			if (  (_hx_switch_0==HX_("good",3d,95,69,44)) ){
HXLINE( 340)				this->addAccuracyText(HX_("GOOD",3d,5d,2a,2f));
HXLINE( 341)				this->good++;
HXLINE( 339)				goto _hx_goto_16;
            			}
            			if (  (_hx_switch_0==HX_("sick",be,8c,53,4c)) ){
HXLINE( 337)				this->addAccuracyText(HX_("SICK",be,54,14,37));
HXLINE( 338)				::PlayState_obj::sick++;
HXLINE( 336)				goto _hx_goto_16;
            			}
            			_hx_goto_16:;
            		}
HXLINE( 348)		this->super::update(elapsed);
            	}


int PlayState_obj::sick;

::String PlayState_obj::rating;

 ::flixel::group::FlxTypedGroup PlayState_obj::receptors;


::hx::ObjectPtr< PlayState_obj > PlayState_obj::__new( ::Dynamic MaxSize) {
	::hx::ObjectPtr< PlayState_obj > __this = new PlayState_obj();
	__this->__construct(MaxSize);
	return __this;
}

::hx::ObjectPtr< PlayState_obj > PlayState_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic MaxSize) {
	PlayState_obj *__this = (PlayState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PlayState_obj), true, "PlayState"));
	*(void **)__this = PlayState_obj::_hx_vtable;
	__this->__construct(MaxSize);
	return __this;
}

PlayState_obj::PlayState_obj()
{
}

void PlayState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PlayState);
	HX_MARK_MEMBER_NAME(good,"good");
	HX_MARK_MEMBER_NAME(bads,"bads");
	HX_MARK_MEMBER_NAME(shitSprite,"shitSprite");
	HX_MARK_MEMBER_NAME(lifeBar,"lifeBar");
	HX_MARK_MEMBER_NAME(health,"health");
	HX_MARK_MEMBER_NAME(noteBool,"noteBool");
	HX_MARK_MEMBER_NAME(holdTimer,"holdTimer");
	HX_MARK_MEMBER_NAME(accuracyText,"accuracyText");
	HX_MARK_MEMBER_NAME(staticArrow,"staticArrow");
	HX_MARK_MEMBER_NAME(daNote,"daNote");
	HX_MARK_MEMBER_NAME(strumLine,"strumLine");
	HX_MARK_MEMBER_NAME(playerStrums,"playerStrums");
	HX_MARK_MEMBER_NAME(notes,"notes");
	HX_MARK_MEMBER_NAME(keys,"keys");
	 ::flixel::FlxState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void PlayState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(good,"good");
	HX_VISIT_MEMBER_NAME(bads,"bads");
	HX_VISIT_MEMBER_NAME(shitSprite,"shitSprite");
	HX_VISIT_MEMBER_NAME(lifeBar,"lifeBar");
	HX_VISIT_MEMBER_NAME(health,"health");
	HX_VISIT_MEMBER_NAME(noteBool,"noteBool");
	HX_VISIT_MEMBER_NAME(holdTimer,"holdTimer");
	HX_VISIT_MEMBER_NAME(accuracyText,"accuracyText");
	HX_VISIT_MEMBER_NAME(staticArrow,"staticArrow");
	HX_VISIT_MEMBER_NAME(daNote,"daNote");
	HX_VISIT_MEMBER_NAME(strumLine,"strumLine");
	HX_VISIT_MEMBER_NAME(playerStrums,"playerStrums");
	HX_VISIT_MEMBER_NAME(notes,"notes");
	HX_VISIT_MEMBER_NAME(keys,"keys");
	 ::flixel::FlxState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val PlayState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"good") ) { return ::hx::Val( good ); }
		if (HX_FIELD_EQ(inName,"bads") ) { return ::hx::Val( bads ); }
		if (HX_FIELD_EQ(inName,"keys") ) { return ::hx::Val( keys ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"notes") ) { return ::hx::Val( notes ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"health") ) { return ::hx::Val( health ); }
		if (HX_FIELD_EQ(inName,"daNote") ) { return ::hx::Val( daNote ); }
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"lifeBar") ) { return ::hx::Val( lifeBar ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"noteBool") ) { return ::hx::Val( noteBool ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"holdTimer") ) { return ::hx::Val( holdTimer ); }
		if (HX_FIELD_EQ(inName,"strumLine") ) { return ::hx::Val( strumLine ); }
		if (HX_FIELD_EQ(inName,"handInput") ) { return ::hx::Val( handInput_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"shitSprite") ) { return ::hx::Val( shitSprite ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"staticArrow") ) { return ::hx::Val( staticArrow ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"accuracyText") ) { return ::hx::Val( accuracyText ); }
		if (HX_FIELD_EQ(inName,"playerStrums") ) { return ::hx::Val( playerStrums ); }
		if (HX_FIELD_EQ(inName,"generateSong") ) { return ::hx::Val( generateSong_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"generateArrow") ) { return ::hx::Val( generateArrow_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"realeasedInput") ) { return ::hx::Val( realeasedInput_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"addAccuracyText") ) { return ::hx::Val( addAccuracyText_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool PlayState_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"sick") ) { outValue = ( sick ); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"rating") ) { outValue = ( rating ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"receptors") ) { outValue = ( receptors ); return true; }
	}
	return false;
}

::hx::Val PlayState_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"good") ) { good=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bads") ) { bads=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"keys") ) { keys=inValue.Cast< ::Array< bool > >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"notes") ) { notes=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"health") ) { health=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"daNote") ) { daNote=inValue.Cast<  ::Note >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"lifeBar") ) { lifeBar=inValue.Cast<  ::flixel::ui::FlxBar >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"noteBool") ) { noteBool=inValue.Cast< ::Array< bool > >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"holdTimer") ) { holdTimer=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"strumLine") ) { strumLine=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"shitSprite") ) { shitSprite=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"staticArrow") ) { staticArrow=inValue.Cast<  ::Receptors >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"accuracyText") ) { accuracyText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"playerStrums") ) { playerStrums=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool PlayState_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"sick") ) { sick=ioValue.Cast< int >(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"rating") ) { rating=ioValue.Cast< ::String >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"receptors") ) { receptors=ioValue.Cast<  ::flixel::group::FlxTypedGroup >(); return true; }
	}
	return false;
}

void PlayState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("good",3d,95,69,44));
	outFields->push(HX_("bads",0e,db,10,41));
	outFields->push(HX_("shitSprite",e5,6f,1b,59));
	outFields->push(HX_("lifeBar",37,1e,5b,84));
	outFields->push(HX_("health",9c,28,06,fd));
	outFields->push(HX_("noteBool",3c,a9,4e,50));
	outFields->push(HX_("holdTimer",06,82,13,a9));
	outFields->push(HX_("accuracyText",86,0f,6a,37));
	outFields->push(HX_("staticArrow",3b,56,5c,3a));
	outFields->push(HX_("daNote",0f,9e,71,09));
	outFields->push(HX_("strumLine",dd,79,d7,ee));
	outFields->push(HX_("playerStrums",4b,e1,2a,0d));
	outFields->push(HX_("notes",41,dc,ca,9f));
	outFields->push(HX_("keys",f4,e1,06,47));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo PlayState_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(PlayState_obj,good),HX_("good",3d,95,69,44)},
	{::hx::fsInt,(int)offsetof(PlayState_obj,bads),HX_("bads",0e,db,10,41)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(PlayState_obj,shitSprite),HX_("shitSprite",e5,6f,1b,59)},
	{::hx::fsObject /*  ::flixel::ui::FlxBar */ ,(int)offsetof(PlayState_obj,lifeBar),HX_("lifeBar",37,1e,5b,84)},
	{::hx::fsInt,(int)offsetof(PlayState_obj,health),HX_("health",9c,28,06,fd)},
	{::hx::fsObject /* ::Array< bool > */ ,(int)offsetof(PlayState_obj,noteBool),HX_("noteBool",3c,a9,4e,50)},
	{::hx::fsFloat,(int)offsetof(PlayState_obj,holdTimer),HX_("holdTimer",06,82,13,a9)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(PlayState_obj,accuracyText),HX_("accuracyText",86,0f,6a,37)},
	{::hx::fsObject /*  ::Receptors */ ,(int)offsetof(PlayState_obj,staticArrow),HX_("staticArrow",3b,56,5c,3a)},
	{::hx::fsObject /*  ::Note */ ,(int)offsetof(PlayState_obj,daNote),HX_("daNote",0f,9e,71,09)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(PlayState_obj,strumLine),HX_("strumLine",dd,79,d7,ee)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(PlayState_obj,playerStrums),HX_("playerStrums",4b,e1,2a,0d)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(PlayState_obj,notes),HX_("notes",41,dc,ca,9f)},
	{::hx::fsObject /* ::Array< bool > */ ,(int)offsetof(PlayState_obj,keys),HX_("keys",f4,e1,06,47)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo PlayState_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &PlayState_obj::sick,HX_("sick",be,8c,53,4c)},
	{::hx::fsString,(void *) &PlayState_obj::rating,HX_("rating",1d,34,8a,bb)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(void *) &PlayState_obj::receptors,HX_("receptors",37,7d,22,c1)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String PlayState_obj_sMemberFields[] = {
	HX_("good",3d,95,69,44),
	HX_("bads",0e,db,10,41),
	HX_("shitSprite",e5,6f,1b,59),
	HX_("lifeBar",37,1e,5b,84),
	HX_("health",9c,28,06,fd),
	HX_("noteBool",3c,a9,4e,50),
	HX_("holdTimer",06,82,13,a9),
	HX_("accuracyText",86,0f,6a,37),
	HX_("staticArrow",3b,56,5c,3a),
	HX_("daNote",0f,9e,71,09),
	HX_("strumLine",dd,79,d7,ee),
	HX_("playerStrums",4b,e1,2a,0d),
	HX_("notes",41,dc,ca,9f),
	HX_("create",fc,66,0f,7c),
	HX_("generateArrow",54,4a,0c,cc),
	HX_("generateSong",aa,ed,2b,1f),
	HX_("keys",f4,e1,06,47),
	HX_("handInput",1b,36,64,89),
	HX_("realeasedInput",52,e8,f4,ae),
	HX_("addAccuracyText",47,7b,b9,bd),
	HX_("update",09,86,05,87),
	::String(null()) };

static void PlayState_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(PlayState_obj::sick,"sick");
	HX_MARK_MEMBER_NAME(PlayState_obj::rating,"rating");
	HX_MARK_MEMBER_NAME(PlayState_obj::receptors,"receptors");
};

#ifdef HXCPP_VISIT_ALLOCS
static void PlayState_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(PlayState_obj::sick,"sick");
	HX_VISIT_MEMBER_NAME(PlayState_obj::rating,"rating");
	HX_VISIT_MEMBER_NAME(PlayState_obj::receptors,"receptors");
};

#endif

::hx::Class PlayState_obj::__mClass;

static ::String PlayState_obj_sStaticFields[] = {
	HX_("sick",be,8c,53,4c),
	HX_("rating",1d,34,8a,bb),
	HX_("receptors",37,7d,22,c1),
	::String(null())
};

void PlayState_obj::__register()
{
	PlayState_obj _hx_dummy;
	PlayState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("PlayState",5d,83,c2,46);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &PlayState_obj::__GetStatic;
	__mClass->mSetStaticField = &PlayState_obj::__SetStatic;
	__mClass->mMarkFunc = PlayState_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(PlayState_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PlayState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PlayState_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = PlayState_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PlayState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PlayState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

